/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Lassi Kaukonen (https://sketchfab.com/thesidekick)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/mm-wave-solar-radio-telescope-c26c5d32954a4908a71ff04c1be88bd4
Title: MM wave Solar radio telescope
*/

import * as THREE from 'three'
import React, { useRef, forwardRef, useImperativeHandle, useMemo } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    Object_2: THREE.Mesh
    Object_3: THREE.Mesh
    Object_4: THREE.Mesh
    Object_5: THREE.Mesh
    Object_6: THREE.Mesh
    Object_7: THREE.Mesh
    Object_8: THREE.Mesh
    Object_9: THREE.Mesh
    Object_10: THREE.Mesh
    Object_11: THREE.Mesh
  }
  materials: {
    Tuorla2020_solar_radio_telescope: THREE.MeshStandardMaterial
  }
}

export interface TelescopeRefs {
  // Main group ref
  group: THREE.Group
  
  // Individual mesh refs for granular control
  meshes: {
    base: THREE.Mesh
    mount: THREE.Mesh
    dish: THREE.Mesh
    support1: THREE.Mesh
    support2: THREE.Mesh
    receiver: THREE.Mesh
    arm1: THREE.Mesh
    arm2: THREE.Mesh
    housing: THREE.Mesh
    antenna: THREE.Mesh
  }
  
  // Materials for styling control
  materials: {
    base: THREE.MeshStandardMaterial
    metallic: THREE.MeshStandardMaterial
    dish: THREE.MeshStandardMaterial
    receiver: THREE.MeshStandardMaterial
  }
  
  // Helper methods for common animations
  rotateDish: (angle: number) => void
  tiltDish: (angle: number) => void
  setEmissive: (color: THREE.Color | string, intensity: number) => void
}

interface RadioHouseProps extends React.ComponentProps<"group"> {
  metalness?: number
  roughness?: number
  color?: string
  emissiveIntensity?: number
}

export const RadioHouse = forwardRef<TelescopeRefs, RadioHouseProps>((props, ref) => {
  const { 
    metalness = 0.8, 
    roughness = 0.2, 
    color = '#e0e0e0',
    emissiveIntensity = 0,
    ...groupProps 
  } = props
  
  const { nodes } = useGLTF('/RadioHouse/scene.gltf') as unknown as GLTFResult
  
  // Main group ref
  const groupRef = useRef<THREE.Group>(null!)
  
  // Individual mesh refs
  const baseRef = useRef<THREE.Mesh>(null!)
  const mountRef = useRef<THREE.Mesh>(null!)
  const dishRef = useRef<THREE.Mesh>(null!)
  const support1Ref = useRef<THREE.Mesh>(null!)
  const support2Ref = useRef<THREE.Mesh>(null!)
  const receiverRef = useRef<THREE.Mesh>(null!)
  const arm1Ref = useRef<THREE.Mesh>(null!)
  const arm2Ref = useRef<THREE.Mesh>(null!)
  const housingRef = useRef<THREE.Mesh>(null!)
  const antennaRef = useRef<THREE.Mesh>(null!)
  
  // Create enhanced materials
  const customMaterials = useMemo(() => {
    const baseColor = new THREE.Color(color)
    
    // Base/mount material - darker metallic
    const baseMaterial = new THREE.MeshStandardMaterial({
      color: baseColor.clone().multiplyScalar(0.6),
      metalness: metalness,
      roughness: roughness + 0.1,
      envMapIntensity: 1.5,
      emissive: new THREE.Color(0x000000),
      emissiveIntensity: emissiveIntensity,
    })
    
    // Metallic parts - shiny metal
    const metallicMaterial = new THREE.MeshStandardMaterial({
      color: baseColor.clone().multiplyScalar(0.8),
      metalness: Math.min(metalness + 0.15, 1),
      roughness: Math.max(roughness - 0.1, 0),
      envMapIntensity: 2,
      emissive: new THREE.Color(0x000000),
      emissiveIntensity: emissiveIntensity,
    })
    
    // Dish material - reflective surface
    const dishMaterial = new THREE.MeshStandardMaterial({
      color: baseColor,
      metalness: Math.min(metalness + 0.2, 1),
      roughness: Math.max(roughness - 0.15, 0.05),
      envMapIntensity: 2.5,
      emissive: new THREE.Color(0x000000),
      emissiveIntensity: emissiveIntensity,
    })
    
    // Receiver/electronics material - less reflective
    const receiverMaterial = new THREE.MeshStandardMaterial({
      color: baseColor.clone().multiplyScalar(0.5),
      metalness: metalness - 0.2,
      roughness: roughness + 0.2,
      envMapIntensity: 1,
      emissive: new THREE.Color(0x000000),
      emissiveIntensity: emissiveIntensity,
    })
    
    return { baseMaterial, metallicMaterial, dishMaterial, receiverMaterial }
  }, [color, metalness, roughness, emissiveIntensity])
  
  // Expose refs and helper methods to parent
  useImperativeHandle(ref, () => ({
    group: groupRef.current,
    meshes: {
      base: baseRef.current,
      mount: mountRef.current,
      dish: dishRef.current,
      support1: support1Ref.current,
      support2: support2Ref.current,
      receiver: receiverRef.current,
      arm1: arm1Ref.current,
      arm2: arm2Ref.current,
      housing: housingRef.current,
      antenna: antennaRef.current,
    },
    materials: {
      base: customMaterials.baseMaterial,
      metallic: customMaterials.metallicMaterial,
      dish: customMaterials.dishMaterial,
      receiver: customMaterials.receiverMaterial,
    },
    rotateDish: (angle: number) => {
      if (dishRef.current) {
        dishRef.current.rotation.y = angle
      }
    },
    tiltDish: (angle: number) => {
      if (dishRef.current) {
        dishRef.current.rotation.x = angle
      }
    },
    setEmissive: (color: THREE.Color | string, intensity: number) => {
      const emissiveColor = typeof color === 'string' ? new THREE.Color(color) : color
      Object.values(customMaterials).forEach(mat => {
        mat.emissive = emissiveColor
        mat.emissiveIntensity = intensity
      })
    },
  }))
  
  return (
    <group ref={groupRef} {...groupProps} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <mesh
          ref={baseRef}
          castShadow
          receiveShadow
          geometry={nodes.Object_2.geometry}
          material={customMaterials.baseMaterial}
        />
        <mesh
          ref={mountRef}
          castShadow
          receiveShadow
          geometry={nodes.Object_3.geometry}
          material={customMaterials.metallicMaterial}
        />
        <mesh
          ref={dishRef}
          castShadow
          receiveShadow
          geometry={nodes.Object_4.geometry}
          material={customMaterials.dishMaterial}
        />
        <mesh
          ref={support1Ref}
          castShadow
          receiveShadow
          geometry={nodes.Object_5.geometry}
          material={customMaterials.metallicMaterial}
        />
        <mesh
          ref={support2Ref}
          castShadow
          receiveShadow
          geometry={nodes.Object_6.geometry}
          material={customMaterials.metallicMaterial}
        />
        <mesh
          ref={receiverRef}
          castShadow
          receiveShadow
          geometry={nodes.Object_7.geometry}
          material={customMaterials.receiverMaterial}
        />
        <mesh
          ref={arm1Ref}
          castShadow
          receiveShadow
          geometry={nodes.Object_8.geometry}
          material={customMaterials.metallicMaterial}
        />
        <mesh
          ref={arm2Ref}
          castShadow
          receiveShadow
          geometry={nodes.Object_9.geometry}
          material={customMaterials.metallicMaterial}
        />
        <mesh
          ref={housingRef}
          castShadow
          receiveShadow
          geometry={nodes.Object_10.geometry}
          material={customMaterials.baseMaterial}
        />
        <mesh
          ref={antennaRef}
          castShadow
          receiveShadow
          geometry={nodes.Object_11.geometry}
          material={customMaterials.receiverMaterial}
        />
      </group>
    </group>
  )
})

RadioHouse.displayName = 'SolarRadioTelescope'

useGLTF.preload('/RadioHouse/scene.gltf')